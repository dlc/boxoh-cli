#!/usr/bin/perl -wl

# ----------------------------------------------------------------------
# boxoh -- Command-line interface to boxoh.com
# Run `boxoh help` to see full usage info
# ----------------------------------------------------------------------

use strict;
use vars qw($ME $DIR %HANDLERS $DB_PATH);

use DBI;
use DBD::SQLite;
use File::Basename qw(basename dirname);
use HTML::Entities qw(decode_entities);
use LWP::Simple qw(get);
use POSIX qw(strftime);
use Time::ParseDate qw(parsedate);
use URI;
use XML::RSS;

use constant BOXOH => "http://boxoh.com/";

my $cmd = shift || 'help';
my $sub = $HANDLERS{$cmd} || $HANDLERS{'default'};

$sub->(Boxoh::Db->instance($DB_PATH), @ARGV);

exit 0;

BEGIN {
    $ME = basename($0);

    # Find the db
    my $dir = dirname($0);
    my @paths = ("./.$ME.db", glob "~/.$ME.db");
    push @paths, "/etc/$ME.db" if $< == 0;

    for my $p (@paths) {
        if (-e $p) {
            $DB_PATH = $p;
            last;
        }
    }
    $DB_PATH ||= $paths[-1];

    # Set up handlers
    %HANDLERS = (

        # Track a new package
        track => sub {
            my $db = shift;

            for (my $i = 0; $i <= @_; $i++) {
                my $t = $_[$i];
                my $pname = "";

                next unless $t;

                # Check for package title; track 1234 as "new book"
                if (lc($_[ $i+1 ]) eq 'as') {
                    $pname = $_[ $i+2 ];
                    $i += 2;
                }

                if ($db->has($t)) {
                    print "Skipping $t; already exists in database";
                    next;
                }

                my ($u, $data, $link, $attrs);

                # Register package with boxoh
                $u = URI->new(BOXOH);
                $u->query_form(t => $t);
                $data = get($u->canonical);
                ($link) = $data =~ m!(<link .+?$t.+?/>)!;
                $attrs = parse_link($link);
                $attrs->{'uri'} = $u;
                $attrs->{'tnum'} = $t;
                $attrs->{'title'} = $pname if $pname;

                if ($attrs->{'href'} && $attrs->{'carrier'}) {
                    print "Storing package data for $t";
                    $db->save($attrs);

                    # Fetch feed
                    if ($attrs->{'href'}) {
                        print "Storing event data for $t";
                        update_feed($db, $attrs);
                    }
                }
                else {
                    print "Boxoh can't handle `$t'; sorry.";
                }
            }
        },

        # Update each feed
        'update-feeds' => sub {
            my $db = shift;
            my $to_update = $db->all('package', 'status != "Delivered"');
            for my $f (@$to_update) {
                print "Updating event stream for $f->{'tnum'}";
                update_feed($db, $f);
            }
        },

        # emit a combined rss feed
        feed => sub {
            my $db = shift;
            my $feed = XML::RSS->new(version => "2.0");
            $feed->channel(
                title           => "Combined Package Tracking Feed, via Boxoh.com",
                link            => "http://boxoh.com/",
                lastBuildDate   => strftime("%Y-%m-%dT%H:%M:%S %Z", localtime),
            );
            my $events = $db->latest();
            for my $e (@$events) {
                $feed->add_item(
                    title       => "$e->{'tnum'}: '$e->{'p_title'}': $e->{'title'}",
                    link        => $e->{'link'},
                    guid        => $e->{'guid'},
                    pubDate     => strftime("%Y-%m-%dT%H:%M:%S %Z", localtime $e->{'date'}),
                    description => $e->{'body'},
                );
            }
            print $feed->as_string;
        },

        # List all packages
        list => sub {
            my $db = shift;
            my $items = $db->all('package', '', 'date DESC');
            for my $i (@$items) {
                my $info = $db->info($i->{'id'});
                printf "% 3d. %s <%s>",
                    $i->{'id'}, $i->{'title'}, $i->{'link'};

                my $d = @{ $info->{'events'} } ? $info->{'events'}->[-1] : {};
                if ($d->{'title'} eq 'Delivered') {
                    printf " -- Delivered %s",
                        strftime "%Y-%m-%d %H:%M", localtime($d->{'date'});
                }

                print "";
            }
        },

        # Warning: this is ugly
        'out-for-delivery' => sub {
            my $db = shift;
            my $items = $db->all('package', "id IN (SELECT pid FROM event WHERE title = 'Out For Delivery' AND pid NOT IN (SELECT pid FROM event WHERE title = 'Delivered'))");
            for my $i (@$items) {
                my $info = $db->info($i->{'id'});
                printf "% 3d. %s <%s>\n",
                    $i->{'id'}, $i->{'title'}, $i->{'link'};
            }
        },

        # Manually remove pacakges
        remove => sub {
            my $db = shift;
            for my $i (@_) {
                my $info = $db->info($i);
                $db->remove($i);
                print "Removed item $i: $info->{'title'}";
            }
        },

        # Rename an item
        'rename' => sub {
            my $db = shift;
            my $tnum = shift;
            my $name = shift;
            $name = shift
                if ($name eq 'to' or $name = 'as');
            my $res = $db->change_name($tnum, $name);
            print "Error renaming item $tnum: $res"
                if $res;
        },

        # Display info on a package
        info => sub {
            my $db = shift;
            if (0 == @_) {
                $HANDLERS{'list'}->($db);
            }
            else {
                for (my $i = 0; $i < @_; $i ++) {
                    my $info = $db->info($_[$i]);
                    print $info->{'title'};
                    print "-" x length($info->{'title'});
                    print "Tracking Number: ", $info->{'tnum'};
                    print "Carrier: ", $info->{'carrier'};
                    print "Status: ", $info->{'status'};
                    print "Link: ", $info->{'link'};
                    print "";
                    print "Package history";
                    print "---------------";

                    for my $e (@{ $info->{'events'} }) {
                        print strftime("%Y/%m/%d %H:%M", localtime($e->{'date'})), ": ", $e->{'title'};
                    }
                }
            }
        },

        # Remove all data for packages marked as delivered
        'pack' => sub {
            my $db = shift;
            my $to_delete = $db->all('package', 'status = "Delivered"');
            $HANDLERS{'remove'}->($db, map { $_->{'id'} } @$to_delete);
        },

        # Print path the the db
        finddb => sub {
            my $db = shift;
            print $DB_PATH;
        },

        help => sub {
            print <<HELP;
$ME - Command-line interface to boxoh.com.

Usage:

    \$ $ME CMD [ARGS]

Where CMD is one of:

    track
        Add one or more items to the list of packages being tracked.
        Pass one or more package IDs to the command.  The title of the
        tracked package defaults to boxoh's name ("\$CARRIER tracking
        information for \$TRACKING_NUMBER") but you can specify your
        own title by declaring the package thusly:

          \$ $ME track 123456789 as "Bday gift for Susan"

        Then, package 123456789 will always be displyed as "Bday
        gift for Susan".  Keep in mind that there is no editing
        feature yet.

    update-feeds
        Grab and parse the RSS feeds for each tracked package.  This
        should be run from cron.

    feed
        Generate a new RSS feed containing aggregated info from all
        followed packages.  Note that this includes delivered packages;
        use pack to remove delivered packages.

        $ME feed emits the feed to stdout, and should be run periodically
        to generate an RSS 2.0 feed, like:

            30 * * * boxoh feed > /src/www/htdocs/packages.rss

    list
        Lists tracked packages to stdout, for manipulation.

    rename
        Renames a tracked package:

            \$ $ME list
            57. USPS Package <http://boxoh.com/?t=123456789>
            \$ $ME rename 123456789 to "Incoming: 'My Life As A Pencil'"
            \$ $ME list
            57. Incoming: 'My Life As A Pencil' <http://boxoh.com/?t=123456789>

    remove
        Remove an individual package from the db.  Packages can be removed
        using their id (from $ME list) or package id.

    info
        Display info on a specific package.  Package info can be displayed
        using their id (from $ME list) or package id.

    out-for-delivery
        Prints a list of items that are currently out for delivery.
        The heuristic used is sketchy, so you shouldn't rely on it.

    pack
        Removes all packages marked as 'Delivered'.  This is to
        unclutter your feed.

    finddb
        Prints the path to the db file.

HELP
        }
    );

    $HANDLERS{'default'}    = $HANDLERS{'help'};

    # Aliases for other commands
    $HANDLERS{'add'}        = $HANDLERS{'track'};
    $HANDLERS{'del'}        = $HANDLERS{'remove'};
    $HANDLERS{'rm'}         = $HANDLERS{'remove'};
    $HANDLERS{'out'}        = $HANDLERS{'out-for-delivery'};
    $HANDLERS{'show'}       = $HANDLERS{'info'};
    $HANDLERS{'update'}     = $HANDLERS{'update-feeds'};

    sub parse_link {
        my %attrs;
        if (my $line = shift) {
            $line =~ s/^<link *//;
            while ($line =~ s/^(\S+)\s*=\s*(['"])(.*?)\2 *//) {
                $attrs{"$1"} = $3;
            }
            ($attrs{'carrier'}) = ($attrs{'title'} || '') =~ /^(\S+)/;
            ($attrs{'href'} ||= '') =~ s/&amp;/&/g;
        }

        return \%attrs;
    }

    sub update_feed {
        my $db = shift;
        my $attrs = shift;
        my ($u, $data);

        $u = URI->new($attrs->{'href'} || $attrs->{'feed'});
        if ($data = get($u->canonical)) {
            my (@items) = $data =~ m!<item>(.+?)</item>!gs;
            for my $item (@items) {
                my %fattr;
                for my $i (qw(title description link pubDate guid id)) {
                    ($fattr{$i}) = $item =~ m!<$i>(.*?)</$i>!s;
                }
                $fattr{'date'} = parsedate($fattr{'pubDate'});
                $fattr{'title'} =~ s/.+: *//;
                $fattr{'guid'} = $fattr{'guid'} || $fattr{'id'} || $fattr{'link'};
                $fattr{'description'} = decode_entities($fattr{'description'});

                $db->save_feed_item($attrs, \%fattr);
                print " * $fattr{'title'}";
            }
        }

        $db->update_status($attrs->{'tnum'});
    }
}

package Boxoh::Db;
use base qw(DBI::db);

{
    my $_db;
    sub instance {
        my $class = shift;
        my $path = shift;
        unless ($_db) {
            my $exists = -e $path;
            $_db = DBI->connect("dbi:SQLite:dbname=$path")
                or die "Can't connect: " . DBI->errstr;

            if (! $exists) {
                for my $c (CREATE()) {
                    $_db->do($c) or die "Error running sql '$c': " . $_db->errstr;
                }
            }

            bless $_db => $class;
        }

        return $_db;
    }
}

# ------------------------------------------------------------------
# $db->has($TRACKING_NUM)
#
# Determine if a package exists in the db
# ------------------------------------------------------------------
sub has {
    my $self = shift;
    my $tnum = shift;
    my $id = $self->pkg_id($tnum);

    return $self->selectrow_array("SELECT COUNT(*) FROM package WHERE id = ?", undef, $id);
}

# ------------------------------------------------------------------
# $db->save(\%pkg)
#
# Save info about a package.
# ------------------------------------------------------------------
sub save {
    my $self = shift;
    my $a = shift;
    $self->do("INSERT INTO package (tnum, title, date, link, feed, carrier) VALUES (?, ?, ?, ?, ?, ?)",
        undef, $a->{'tnum'}, $a->{'title'}, time, $a->{'uri'}, $a->{'href'}, $a->{'carrier'});
}

# ------------------------------------------------------------------
# $db->save_feed_item(\%pkg, \%feed)
#
# Saves a feed event.
# ------------------------------------------------------------------
sub save_feed_item {
    my $self = shift;
    my $p = shift;
    my $i = shift;

    if (my $id = $self->pkg_id($p->{'tnum'})) {
        $self->do("DELETE FROM event WHERE guid = ?", undef, $i->{'guid'});
        $self->do("INSERT INTO event (pid, title, date, link, guid, body) VALUES (?, ?, ?, ?, ?, ?)",
            undef, $id, $i->{'title'}, $i->{'date'}, $i->{'link'}, $i->{'guid'}, $i->{'description'});
    }
}

# ------------------------------------------------------------------
# $db->latest([$num])
#
# Returns the latest $num items
# ------------------------------------------------------------------
sub latest {
    my $self = shift;
    my $num = shift || '';
    my @events;

    my $sql = "
        SELECT p.tnum, p.title as p_title, e.guid, e.title, e.date, e.link, e.body
          FROM package p, event e
         WHERE p.id = e.pid
         ORDER BY e.date DESC";
    if ($num) { $sql .= "LIMIT $num"; }

    my $sth = $self->prepare($sql);
    $sth->execute;
    while (my $e = $sth->fetchrow_hashref) {
        push @events, $e;
    }
    $sth->finish;

    return \@events;
}

# ------------------------------------------------------------------
# $db->pkg_id($TRACKING_NUM)
#
# Returns the db id of $TRACKING_NUM.  If $TRACKING_NUM is already
# an id, then return that.  Otherwise, return undef.
# ------------------------------------------------------------------
sub pkg_id {
    my $self = shift;
    my $tnum = shift;
    my $id;

    if ($id = $self->selectrow_array("SELECT id FROM package WHERE id = ?", undef, $tnum)) {
        return $id;
    }

    if ($id = $self->selectrow_array("SELECT id FROM package WHERE tnum = ?", undef, $tnum)) {
        return $id;
    }

    return;
}

# ------------------------------------------------------------------
# $db->update_status($TRACKING_NUM)
#
# Upates the package table with the latest info from the event table
# ------------------------------------------------------------------
sub update_status {
    my $self = shift;
    my $tnum = shift;

    if (my $id = $self->pkg_id($tnum)) {
        $self->do("
            UPDATE package
               SET status = (SELECT title FROM event WHERE pid = ? ORDER BY date DESC LIMIT 1)
             WHERE id = ?", undef, $id, $id);
    }
}

# ------------------------------------------------------------------
# $db->all()
#
# Return every package in the db as an arrayref of hashrefs
# ------------------------------------------------------------------
sub all {
    my $self = shift;
    my $table = shift;
    my $where = shift || '1 = 1';
    my $order = shift || 'id ASC';
    my @items;

    my $sth = $self->prepare("
        SELECT *
          FROM $table
         WHERE $where
         ORDER BY $order");

    $sth->execute;
    while (my $r = $sth->fetchrow_hashref) {
        push @items, $r;
    }
    $sth->finish;

    return \@items;
}

# ------------------------------------------------------------------
# $db->remove($TRACKING_NUM)
# Remove a package from the db
# ------------------------------------------------------------------
sub remove {
    my $self = shift;
    my $i = shift;
    if (my $id = $self->pkg_id($i)) {
        $self->do("DELETE FROM package WHERE id = ?", undef, $id);
        $self->do("DELETE FROM event WHERE pid = ?", undef, $id);
    }
}

# ------------------------------------------------------------------
# $db->info($TRACKING_NUM)
#
# Return info on $TRACKING_NUM
# ------------------------------------------------------------------
sub info {
    my $self = shift;
    my $tnum = shift;
    my %info;

    if (my $id = $self->pkg_id($tnum)) {
        my $sth = $self->prepare("
                SELECT *
                  FROM package
                 WHERE id = ?");
        $sth->execute($id);
        %info = (%{ $sth->fetchrow_hashref });
        $sth->finish;

        $info{'events'} = $self->all(
            'event',
            "pid = $id",
            "date ASC");
    }

    return \%info;
}

# ------------------------------------------------------------------
# $db->change_name($ID, $NAME)
#
# Changes the name of $ID to $NAME
# ------------------------------------------------------------------
sub change_name {
    my $self = shift;
    my $tnum = shift;
    my $name = shift;
    my $err;

    if (my $id = $self->pkg_id($tnum)) {
        my $sth = $self->prepare("UPDATE package SET title = ? WHERE id = ?");

        if ($sth->execute($name, $id)) {
            $sth->finish;
        }
        else {
            $err = $sth->errstr;
        }
    }
    else {
        $err = "Can't find package '$tnum'";
    }

    return $err;
}

# ------------------------------------------------------------------
# $db->CREATE()
#
# Return the schema, for creating the db.
# Note that this assumes SQLite, for now.
# ------------------------------------------------------------------
sub CREATE {
    return (
        q~CREATE TABLE package (id INTEGER PRIMARY KEY, tnum, title, date INTEGER, link, feed, status, carrier)~,
        q~CREATE TABLE event (id INTEGER PRIMARY KEY, pid INTEGER, guid, title, date INTEGER, link, body)~,
    );
}
